#!/bin/bash
#
# script: rc.library.source
#
# Library used by nfsd, ntpd, rpc, samba, nginx, sshd, avahidaemon, show_interfaces
#
# Bergware - created for Unraid OS, October 2023

WIREGUARD="/etc/wireguard"
NETWORK_INI="/var/local/emhttp/network.ini"
NETWORK_EXTRA="/boot/config/network-extra.cfg"

ipv(){
  T=${1//[^:]}
  [[ ${#T} -le 1 ]] && echo 4 || echo 6
}

this(){
  local LIST ADDR
  case $CALLER in
  'avahi')
    grep -Pom1 "^$1=\K.*" $CONF
    ;;
  'smb')
    grep -Pom1 "^$1 = \K.*" $CONF
    ;;
  'ntp'|'ssh')
    grep -Po "^$1 \K\S+" $CONF | tr '\n' ' ' | sed 's/ $//'
    ;;
  'nfs')
    grep -Pom1 "^RPC_NFSD_OPTS=\"$OPTIONS \K[^\"]+" $NFS
    ;;
  'rpc')
    grep -Pom1 "^RPCBIND_OPTS=\"\K[^\"]+" $RPC
    ;;
  'nginx')
    LIST=();
    for ADDR in $(awk '$1=="listen" && $2~/^[0-9]|\[/ && $0~/http2; #.*$/{print $2}' $SERVERS 2>/dev/null); do
      # extract ipv4 / ipv6 address
      [[ $(ipv $ADDR) == 4 ]] && ADDR=${ADDR%:*} || ADDR=${ADDR#*[} ADDR=${ADDR%]*}
      LIST+=($ADDR)
    done
    # return addresses
    echo ${LIST[@]}
    ;;
  esac
}

scan(){
  grep -Pom1 "^$1=\"?\K[^\"]+" $2
}

good(){
  local BAD=
  for i in ${BIND[@]}; do
    [[ -z $1 || $1 == $i || ${1:0:4} == fe80 ]] && BAD=1
  done
  echo $BAD
}

show(){
  case $# in
    1) ip -br addr show scope global to $1 2>/dev/null | awk '{print $1;exit}';;
    2) ip -br addr show scope global $1 $2 2>/dev/null | awk '{$1=$2="";print;exit}' | sed -r 's/ metric [0-9]+//g';;
  esac
}

unmask(){
  if [[ $CALLER == smb && -z $DENY6 ]]; then
    # replace netmask
    [[ $(ipv $1) == 4 ]] && echo ${1/\/32/\/24} || echo ${1/\/128/\/64}
  else
    # remove netmask
    echo ${1/\/*}
  fi
}

remove(){
  local ADDR
  for ADDR in $@; do
    ADDR=$(unmask $ADDR)
    for i in ${!BIND[@]}; do
      [[ $ADDR == ${BIND[$i]} ]] && unset 'BIND[i]'
    done
  done
}

isname(){
  [[ -z ${1//[^.:]} || ${1//[^.:]} == . ]] && return 0 || return 1
}

extra_name(){
  local NET
  for NET in $include_interfaces; do
    if $(isname $NET); then
      # NET is an interface name, validate
      [[ -n $(show dev $NET) && -z $(good $NET) ]] && BIND+=($NET)
    else
      # NET is an IP address, convert to name
      NET=$(show $NET)
      [[ -n $NET && -z $(good $NET) ]] && BIND+=($NET)
    fi
  done
  for NET in $exclude_interfaces; do
    if $(isname $NET); then
      # NET is an interface name, remove
      remove "$NET"
    else
      # NET is an IP address, convert to name and remove
      remove "$(show $NET)"
    fi
  done
}

extra_addr(){
  local NET LIST ADDR
  [[ $CALLER == ntp ]] && return
  for NET in $include_interfaces; do
    if $(isname $NET); then
      # NET is an interface name, get IP addresses
      LIST="$(show dev $NET)"
    else
      # NET is an IP address, validate
      LIST="$(show to $NET)"
    fi
    for ADDR in $LIST; do
      ADDR=$(unmask $ADDR)
      [[ -z $(good $ADDR) ]] && BIND+=($ADDR) || continue
      [[ $(ipv $ADDR) == 4 ]] && IPV4=yes || IPV6=yes
    done
  done
  for NET in $exclude_interfaces; do
    if $(isname $NET); then
      # NET is an interface name, get IP addresses
      remove "$(show dev $NET)"
    else
      # NET is an IP address
      remove "$(show to $NET)"
    fi
  done
}

check(){
  # quick check
  [[ -n $BIND ]] && return 0;
  # preset return values
  BIND=(); IPV4=no; IPV6=no; FAMILY=any;
  # read active interfaces (including wireguard tunnels)
  while IFS=$'\n' read -r NET; do
    NET=($NET)
    if [[ ${NET:0:2} == wg ]]; then
      # skip wireguard tunnel if NTP or VPN type
      [[ $CALLER == ntp || $(grep -Pom1 '^TYPE:1="\K[^"]+' $WIREGUARD/$NET.cfg) == 8 ]] && continue
    fi
    for ADDR in ${NET[@]/$NET}; do
      ADDR=$(unmask $ADDR)
      if [[ "avahi show" =~ "$CALLER" ]]; then
        [[ -z $(good $NET) ]] && BIND+=($NET) || continue
      else
        [[ -z $(good $ADDR) ]] && BIND+=($ADDR) || continue
      fi
      [[ $(ipv $ADDR) == 4 ]] && IPV4=yes || IPV6=yes
    done
  done <<< $(ip -br addr show scope global | awk '$1~"(br|bond|eth|wg)[0-9]+(.[0-9]+)?" && $3!="" {gsub("@.+","",$1);$2="";print}' | sed -r 's/ metric [0-9]+//g' | sort)
  # add loopback interface
  if [[ "smb nfs" =~ "$CALLER" ]]; then
    [[ $IPV4 == yes ]] && BIND+=(127.0.0.1)
    [[ $IPV6 == yes ]] && BIND+=(::1)
  fi
  # add user defined interfaces
  if [[ -f $NETWORK_EXTRA ]]; then
    . <(fromdos <$NETWORK_EXTRA)
    [[ "avahi show" =~ "$CALLER" ]] && extra_name || extra_addr
  fi
  if [[ $CALLER == ssh ]]; then
    # BIND stays array
    BIND=(${BIND[@]})
    [[ $IPV4 == yes && $IPV6 == no ]] && FAMILY=inet
    [[ $IPV6 == yes && $IPV4 == no ]] && FAMILY=inet6
  else
    # convert array to string
    BIND=${BIND[@]}
    [[ $CALLER == avahi ]] && BIND=${BIND// /,}
  fi
  return 0
}
